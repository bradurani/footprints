{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/ulid/dist/index.esm.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","createError","message","err","Error","source","ENCODING","ENCODING_LEN","length","TIME_MAX","Math","pow","TIME_LEN","RANDOM_LEN","randomChar","prng","rand","floor","charAt","encodeTime","now","len","isNaN","Number","isInteger","mod","str","encodeRandom","detectPrng","allowInsecure","arguments","undefined","root","window","browserCrypto","crypto","msCrypto","buffer","Uint8Array","getRandomValues","nodeCrypto","randomBytes","readUInt8","e","console","error","random","factory","currPrng","seedTime","Date","src_ulid","LIB_NAME","DEFAULT_INTERVAL_WAIT","init","footprints","initialized","state","basePayload","inputQueue","q","outputQueue","noop","identity","a","endpointUrl","successCallback","errorCallback","uniqueIdFunc","readyCallback","transformPayloadFunc","debug","fetchOptions","maxAttempts","processQueues","processInputQueue","processAction","fire","enqueueOutput","processOutputQueue","send","sendComplete","sendError","actions","pageProps","trace","toArray","args","slice","options","toUpperCase","opts","intervalWait","pageTime","toISOString","pageId","safeProcessQueues","push","setInterval","cmd","actionName","shift","f","apply","eventType","properties","obj","payload","JSON","parse","stringify","attempt","msg","fetchParams","assign","method","headers","Content-Type","body","fetch","then","response","status","statusText","bind","catch","pageView","props","user","idOrProperties","context","track","eventName","url","location","href","path","referer","document","title","unshift","log","this","action","methodName"],"mappings":"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","file":"footprints.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","function createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = require(\"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };\n","import { factory, detectPrng } from 'ulid';\n\nvar prng = detectPrng(true); // pass `true` to allow insecure Math.rand\nvar ulid = factory(prng);\n\nvar LIB_NAME = 'Footprints';\nvar DEFAULT_INTERVAL_WAIT = 5000;\nvar PAUSE_TIME = 100;\n\nexport function init(footprints){\n  if(footprints.initialized){\n    console.error('Footprints already initialized');\n    return;\n  }\n  footprints.initialized = true;\n\n  footprints.state = {\n    basePayload: {},\n    inputQueue: footprints.q || [],\n    outputQueue: []\n  };\n\n  footprints.noop = function(){};\n  footprints.identity = function(a){ return a; };\n\n  //utlities methods\n  var toArray = function(args) {\n    return [].slice.call(args);\n  };\n\n  var clone = function(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  };\n\n  (function performSetup(){\n\n    if (typeof footprints.options == 'undefined'){\n      throw LIB_NAME.toUpperCase() + \": your snippet must set \" +\n        LIB_NAME + \".options to the options object\";\n    }\n\n    // validate options\n    (function(opts){\n      if(typeof opts.endpointUrl == 'undefined'){\n        throw LIB_NAME.toUpperCase() + \": you must pass the option endpointUrl\";\n      }\n\n      // set default values for optional arguments\n      opts.intervalWait = opts.intervalWait || DEFAULT_INTERVAL_WAIT;\n      opts.debug = opts.debug || false;\n      opts.pageTime = (opts.pageTime || new Date()).toISOString();\n      opts.successCallback = opts.successCallback || footprints.noop;\n      opts.errorCallback = opts.errorCallback || footprints.noop;\n      opts.uniqueIdFunc = opts.uniqueIdFunc || ulid;\n      opts.readyCallback = opts.readyCallback || footprints.noop;\n      opts.transformPayloadFunc = opts.transformPayloadFunc || footprints.identity;\n      opts.pageId = opts.pageId || opts.uniqueIdFunc();\n      opts.fetchOptions = opts.fetchOptions || {};\n      opts.maxAttempts = opts.maxAttempts || 'unlimited';\n    })(footprints.options);\n\n    footprints.state.basePayload.pageTime = footprints.options.pageTime;\n    footprints.state.basePayload.pageId = footprints.options.pageId;\n\n    var safeProcessQueues = function(){\n      if(typeof footprints.processQueues === 'function'){\n        footprints.processQueues();\n      }\n    };\n\n    // replace the push method from the snippet with one\n    // that calls processQueue so we don't have to wait for the timer\n    footprints.push = function(){\n      footprints.state.inputQueue.push(toArray(arguments));\n      safeProcessQueues();\n    };\n\n    // set a timer to process retries periodicaly\n    window.setInterval(function(){\n      safeProcessQueues();\n    }, footprints.options.intervalWait);\n  })();\n\n  (function run(\n    inputQueue,\n    outputQueue,\n    basePayload,\n    endpointUrl,\n    successCallback,\n    errorCallback,\n    uniqueIdFunc,\n    readyCallback,\n    transformPayloadFunc,\n    debug,\n    fetchOptions,\n    maxAttempts\n  ) {\n\n    var processQueues = footprints.processQueues = function(){\n      processInputQueue();\n      processOutputQueue();\n    };\n\n    var processInputQueue = function() {\n      trace(\"processing input queue\", inputQueue);\n      var cmd;\n      var actionName;\n      while (cmd = inputQueue.shift()) {\n        actionName = cmd.shift();\n        processAction(actionName, cmd);\n      }\n    };\n\n    var processAction = function(actionName, args) {\n      trace('processing action ', actionName, args);\n      var f = actions[actionName];\n      if (typeof f === \"function\") {\n        f.apply(null, args);\n      } else {\n        error(\"Unknown function\", actionName);\n      }\n    };\n\n    var fire = function(eventType, properties) {\n      var payload = clone(properties);\n      payload['eventTime'] = new Date().toISOString();\n      payload['eventId'] = uniqueIdFunc();\n      payload['eventType'] = eventType;\n      payload = transformPayloadFunc(payload);\n      enqueueOutput(payload, 0);\n    };\n\n    var enqueueInput = function(payload){\n      inputQueue.push(payload);\n    };\n\n    var enqueueOutput = function(payload, attempt) {\n      outputQueue.push({ attempt: attempt, payload: payload });\n    };\n\n    var processOutputQueue = function() {\n      trace(\"processing output queue\");\n      var msg;\n      while (msg = outputQueue.shift()) {\n        send(msg.payload, msg.attempt);\n      }\n    };\n\n    var send = function(payload, attempt) {\n      trace(\"sending event\", payload);\n      var fetchParams = Object.assign({\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      }, fetchOptions);\n      fetch(endpointUrl, fetchParams).then(function(response){\n        if (response.status >= 200 && response.status < 300) {\n          return response;\n        } else {\n          var error = new Error(response.statusText);\n          error.response = response;\n          throw error;\n        }\n      }).then(sendComplete.bind(null, payload))\n        .catch(function(e){\n          sendError(payload, attempt, e);\n        });\n    };\n\n    var sendComplete = function(payload, response) {\n      successCallback(response);\n      trace('Event Sent', payload);\n    };\n\n    var sendError = function(payload, attempt, e) {\n      if(maxAttempts == 'unlimited' || attempt + 1 < maxAttempts)\n        enqueueOutput(payload, attempt + 1);\n      errorCallback(e);\n      error('Event Failed', e, payload, { attempt: attempt });\n    };\n\n    var actions = {\n      pageView: function(name, properties) {\n        var props = Object.assign({}, basePayload, properties, pageProps());\n        if(name){\n          props['name'] = name;\n        }\n        fire('pageView', props);\n      },\n      user: function(idOrProperties, properties){\n        var props = Object.assign({}, properties);\n        if(typeof idOrProperties === 'object'){\n          props = Object.assign(props, idOrProperties);\n        } else if(idOrProperties){\n          props['userId'] = idOrProperties;\n        }\n        actions.context(props);\n      },\n      track: function(eventName, properties){\n        var props = Object.assign(basePayload, properties);\n        if(eventName){\n          props['eventName'] = eventName;\n        }\n        fire('track', props);\n      },\n      context: function(context) {\n        footprints.state.basePayload =\n          basePayload =\n          Object.assign(basePayload, context);\n      }\n    };\n\n    var pageProps = function(){\n      var pageProps = {};\n      try {\n        pageProps.url = window.location.href;\n        pageProps.path = window.location.path;\n        pageProps.referer = document.referer;\n        pageProps.title = document.title;\n      } catch(e){\n        error('could not get page props', e);\n      }\n      return pageProps;\n    };\n\n    var trace = function() {\n      if (debug) {\n        var args = toArray(arguments);\n        args.unshift(LIB_NAME + ':');\n        console.log.apply(this, args);\n      }\n    };\n\n    var error = function() {\n      if (debug) {\n        var args = toArray(arguments);\n        args.unshift(LIB_NAME + ':');\n        console.error.apply(this, args);\n      }\n    };\n\n    //add all actions to Footprints as methods in case the snippet did not\n    (function(){\n      for (var action in actions) {\n        if (actions.hasOwnProperty(action)) {\n          footprints[action] = (function(methodName){\n            return function(){\n              var args = toArray(arguments);\n              args.unshift(methodName);\n              enqueueInput(args);\n              processQueues();\n            };\n          })(action);\n        }\n      }\n    })();\n\n    //start so we don't have to wait for the first interval\n    readyCallback();\n    processQueues();\n  })(footprints.state.inputQueue,\n    footprints.state.outputQueue,\n    footprints.state.basePayload,\n    footprints.options.endpointUrl,\n    footprints.options.successCallback,\n    footprints.options.errorCallback,\n    footprints.options.uniqueIdFunc,\n    footprints.options.readyCallback,\n    footprints.options.transformPayloadFunc,\n    footprints.options.debug,\n    footprints.options.fetchOptions,\n    footprints.options.maxAttempts\n  );\n}\n\nif(window[LIB_NAME]){\n  init(window[LIB_NAME]);\n}\n"],"sourceRoot":""}