{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/ulid/dist/index.esm.js","webpack:///./src/index.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","configurable","enumerable","get","r","value","n","__esModule","object","property","prototype","hasOwnProperty","p","s","createError","message","err","Error","source","ENCODING","ENCODING_LEN","length","TIME_MAX","Math","pow","TIME_LEN","RANDOM_LEN","randomChar","prng","rand","floor","charAt","encodeTime","now","len","isNaN","Number","isInteger","mod","str","encodeRandom","detectPrng","allowInsecure","arguments","undefined","root","window","browserCrypto","crypto","msCrypto","buffer","Uint8Array","getRandomValues","nodeCrypto","randomBytes","readUInt8","e","console","error","random","factory","currPrng","seedTime","Date","src_ulid","LIB_NAME","DEFAULT_INTERVAL_WAIT","init","footprints","initialized","state","basePayload","inputQueue","q","outputQueue","noop","endpointUrl","successCallback","errorCallback","uniqueIdFunc","readyCallback","debug","processQueues","processInputQueue","processAction","fire","enqueueOutput","processOutputQueue","send","sendComplete","sendError","actions","pageProps","trace","toArray","args","slice","options","toUpperCase","opts","intervalWait","pageTime","toISOString","pageId","safeProcessQueues","push","setInterval","cmd","actionName","shift","f","apply","eventName","properties","obj","payload","JSON","parse","stringify","fetch","method","headers","Content-Type","body","then","response","status","statusText","bind","catch","pageView","props","assign","user","idOrProperties","context","track","key","url","location","href","path","referer","document","title","unshift","log","this","action","methodName"],"mappings":"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","file":"footprints.min.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","function createError(message) {\n    var err = new Error(message);\n    err.source = \"ulid\";\n    return err;\n}\n// These values should NEVER change. If\n// they do, we're no longer making ulids!\nvar ENCODING = \"0123456789ABCDEFGHJKMNPQRSTVWXYZ\"; // Crockford's Base32\nvar ENCODING_LEN = ENCODING.length;\nvar TIME_MAX = Math.pow(2, 48) - 1;\nvar TIME_LEN = 10;\nvar RANDOM_LEN = 16;\nfunction replaceCharAt(str, index, char) {\n    if (index > str.length - 1) {\n        return str;\n    }\n    return str.substr(0, index) + char + str.substr(index + 1);\n}\nfunction incrementBase32(str) {\n    var done = undefined;\n    var index = str.length;\n    var char = void 0;\n    var charIndex = void 0;\n    var maxCharIndex = ENCODING_LEN - 1;\n    while (!done && index-- >= 0) {\n        char = str[index];\n        charIndex = ENCODING.indexOf(char);\n        if (charIndex === -1) {\n            throw createError(\"incorrectly encoded string\");\n        }\n        if (charIndex === maxCharIndex) {\n            str = replaceCharAt(str, index, ENCODING[0]);\n            continue;\n        }\n        done = replaceCharAt(str, index, ENCODING[charIndex + 1]);\n    }\n    if (typeof done === \"string\") {\n        return done;\n    }\n    throw createError(\"cannot increment this string\");\n}\nfunction randomChar(prng) {\n    var rand = Math.floor(prng() * ENCODING_LEN);\n    if (rand === ENCODING_LEN) {\n        rand = ENCODING_LEN - 1;\n    }\n    return ENCODING.charAt(rand);\n}\nfunction encodeTime(now, len) {\n    if (isNaN(now)) {\n        throw new Error(now + \" must be a number\");\n    }\n    if (now > TIME_MAX) {\n        throw createError(\"cannot encode time greater than \" + TIME_MAX);\n    }\n    if (now < 0) {\n        throw createError(\"time must be positive\");\n    }\n    if (Number.isInteger(now) === false) {\n        throw createError(\"time must be an integer\");\n    }\n    var mod = void 0;\n    var str = \"\";\n    for (; len > 0; len--) {\n        mod = now % ENCODING_LEN;\n        str = ENCODING.charAt(mod) + str;\n        now = (now - mod) / ENCODING_LEN;\n    }\n    return str;\n}\nfunction encodeRandom(len, prng) {\n    var str = \"\";\n    for (; len > 0; len--) {\n        str = randomChar(prng) + str;\n    }\n    return str;\n}\nfunction decodeTime(id) {\n    if (id.length !== TIME_LEN + RANDOM_LEN) {\n        throw createError(\"malformed ulid\");\n    }\n    var time = id.substr(0, TIME_LEN).split(\"\").reverse().reduce(function (carry, char, index) {\n        var encodingIndex = ENCODING.indexOf(char);\n        if (encodingIndex === -1) {\n            throw createError(\"invalid character found: \" + char);\n        }\n        return carry += encodingIndex * Math.pow(ENCODING_LEN, index);\n    }, 0);\n    if (time > TIME_MAX) {\n        throw createError(\"malformed ulid, timestamp too large\");\n    }\n    return time;\n}\nfunction detectPrng() {\n    var allowInsecure = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    var root = arguments[1];\n\n    if (!root) {\n        root = typeof window !== \"undefined\" ? window : null;\n    }\n    var browserCrypto = root && (root.crypto || root.msCrypto);\n    if (browserCrypto) {\n        return function () {\n            var buffer = new Uint8Array(1);\n            browserCrypto.getRandomValues(buffer);\n            return buffer[0] / 0xff;\n        };\n    } else {\n        try {\n            var nodeCrypto = require(\"crypto\");\n            return function () {\n                return nodeCrypto.randomBytes(1).readUInt8() / 0xff;\n            };\n        } catch (e) {}\n    }\n    if (allowInsecure) {\n        try {\n            console.error(\"secure crypto unusable, falling back to insecure Math.random()!\");\n        } catch (e) {}\n        return function () {\n            return Math.random();\n        };\n    }\n    throw createError(\"secure crypto unusable, insecure Math.random not allowed\");\n}\nfunction factory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        return encodeTime(seedTime, TIME_LEN) + encodeRandom(RANDOM_LEN, currPrng);\n    };\n}\nfunction monotonicFactory(currPrng) {\n    if (!currPrng) {\n        currPrng = detectPrng();\n    }\n    var lastTime = 0;\n    var lastRandom = void 0;\n    return function ulid(seedTime) {\n        if (isNaN(seedTime)) {\n            seedTime = Date.now();\n        }\n        if (seedTime <= lastTime) {\n            var incrementedRandom = lastRandom = incrementBase32(lastRandom);\n            return encodeTime(lastTime, TIME_LEN) + incrementedRandom;\n        }\n        lastTime = seedTime;\n        var newRandom = lastRandom = encodeRandom(RANDOM_LEN, currPrng);\n        return encodeTime(seedTime, TIME_LEN) + newRandom;\n    };\n}\nvar ulid = factory();\n\nexport { replaceCharAt, incrementBase32, randomChar, encodeTime, encodeRandom, decodeTime, detectPrng, factory, monotonicFactory, ulid };\n","import { factory, detectPrng } from 'ulid';\n\nvar prng = detectPrng(true); // pass `true` to allow insecure\nvar ulid = factory(prng);\n\n/* lint for semicolons */\n\nvar LIB_NAME = 'Footprints';\nvar DEFAULT_INTERVAL_WAIT = 5000;\nvar PAUSE_TIME = 100;\n\nexport function init(footprints){\n  if(footprints.initialized){\n    console.error('Footprints already initialized');\n    return;\n  }\n  footprints.initialized = true;\n\n  footprints.state = {\n    basePayload: {},\n    inputQueue: footprints.q || [],\n    outputQueue: []\n  };\n\n  footprints.noop = function(){};\n\n  //utlities methods\n  var toArray = function(args) {\n    return [].slice.call(args);\n  };\n\n  var clone = function(obj) {\n    return JSON.parse(JSON.stringify(obj));\n  };\n\n  (function performSetup(){\n\n    if (typeof footprints.options == 'undefined'){\n      throw LIB_NAME.toUpperCase() + \": your snippet must set \" +\n        LIB_NAME + \".options to the options object\";\n    }\n\n    // validate options\n    (function(opts){\n      if(typeof opts.endpointUrl == 'undefined'){\n        throw LIB_NAME.toUpperCase() + \": you must pass the option endpointUrl\";\n      }\n\n      // set default values for optional arguments\n      opts.intervalWait = opts.intervalWait || DEFAULT_INTERVAL_WAIT;\n      opts.debug = opts.debug || false;\n      opts.pageTime = (opts.pageTime || new Date()).toISOString();\n      opts.successCallback = opts.successCallback || footprints.noop;\n      opts.errorCallback = opts.errorCallback || footprints.noop;\n      opts.uniqueIdFunc = opts.uniqueIdFunc || ulid;\n      opts.readyCallback = opts.readyCallback || footprints.noop;\n      opts.pageId = opts.pageId || opts.uniqueIdFunc();\n    })(footprints.options);\n\n    footprints.state.basePayload.pageTime = footprints.options.pageTime;\n    footprints.state.basePayload.pageId = footprints.options.pageId;\n\n    var safeProcessQueues = function(){\n      if(typeof footprints.processQueues === 'function'){\n        footprints.processQueues();\n      }\n    }\n\n    // replace the push method from the snippet with one\n    // that calls processQueue so we don't have to wait for the timer\n    footprints.push = function(){\n      footprints.state.inputQueue.push(toArray(arguments));\n      safeProcessQueues();\n    };\n\n    // set a timer to process retries periodicaly\n    window.setInterval(function(){\n      safeProcessQueues();\n    }, footprints.options.intervalWait);\n  })();\n\n  (function run(\n    inputQueue,\n    outputQueue,\n    basePayload,\n    endpointUrl,\n    successCallback,\n    errorCallback,\n    uniqueIdFunc,\n    readyCallback,\n    debug\n  ) {\n\n    var processQueues = footprints.processQueues = function(){\n      processInputQueue();\n      processOutputQueue();\n    }\n\n    var processInputQueue = function() {\n      trace(\"processing input queue\", inputQueue);\n      var cmd;\n      var actionName;\n      while (cmd = inputQueue.shift()) {\n        actionName = cmd.shift();\n        processAction(actionName, cmd);\n      }\n    };\n\n    var processAction = function(actionName, args) {\n      trace('processing action ', actionName, args);\n      var f = actions[actionName];\n      if (typeof f === \"function\") {\n        f.apply(null, args);\n      } else {\n        error(\"Unknown function\", actionName);\n      }\n    };\n\n    var fire = function(eventName, properties) {\n      var payload = clone(properties);\n      payload['eventTime'] = new Date().toISOString();\n      payload['eventId'] = uniqueIdFunc();\n      payload['eventName'] = eventName;\n      enqueueOutput(payload);\n    };\n\n    var enqueueInput = function(payload){\n      inputQueue.push(payload);\n    };\n\n    var enqueueOutput = function(payload) {\n      outputQueue.push(payload);\n    };\n\n    var processOutputQueue = function() {\n      trace(\"processing output queue\");\n      var payload;\n      while (payload = outputQueue.shift()) {\n        send(payload);\n      }\n    };\n\n    var send = function(payload) {\n      trace(\"sending event\", payload)\n      fetch(endpointUrl, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(payload)\n      }).then(function(response){\n        if (response.status >= 200 && response.status < 300) {\n          return response;\n        } else {\n          var error = new Error(response.statusText);\n          error.response = response;\n          throw error;\n        }\n      }).then(sendComplete.bind(null, payload))\n        .catch(function(e){\n          sendError(payload, e);\n        });\n    };\n\n    var sendComplete = function(payload, response) {\n      successCallback(response);\n      trace('Event Sent', payload);\n    };\n\n    var sendError = function(payload, e) {\n      enqueueOutput(payload);\n      errorCallback(e)\n      error('Event Failed', e, payload);\n    };\n\n    var actions = {\n      pageView: function(name, properties) {\n        var props = Object.assign({}, basePayload, properties, pageProps());\n        if(name){\n          props['name'] = name;\n        }\n        fire('pageView', props);\n      },\n      user: function(idOrProperties, properties){\n        var props = Object.assign({}, properties);\n        if(typeof idOrProperties === 'object'){\n          props = Object.assign(props, idOrProperties);\n        } else if(idOrProperties){\n          props['userId'] = idOrProperties;\n        }\n        actions.context(props);\n      },\n      track: function(key, properties){\n        var props = Object.assign(basePayload, properties);\n        if(key){\n          props['key'] = key;\n        }\n        fire('track', props);\n      },\n      context: function(context) {\n        footprints.state.basePayload =\n          basePayload =\n          Object.assign(basePayload, context);\n      }\n    };\n\n    var pageProps = function(){\n      var pageProps = {};\n      try {\n        pageProps.url = window.location.href;\n        pageProps.path = window.location.path;\n        pageProps.referer = document.referer;\n        pageProps.title = document.title;\n      } catch(e){\n        error('could not get page props', e);\n      }\n      return pageProps;\n    }\n\n    var trace = function() {\n      if (debug) {\n        var args = toArray(arguments);\n        args.unshift(LIB_NAME + ':');\n        console.log.apply(this, args);\n      }\n    };\n\n    var error = function() {\n      if (debug) {\n        var args = toArray(arguments);\n        args.unshift(LIB_NAME + ':');\n        console.error.apply(this, args);\n      }\n    };\n\n    //add all actions to Footprints as methods in case the snippet did not\n    (function(){\n      for (var action in actions) {\n        if (actions.hasOwnProperty(action)) {\n          footprints[action] = (function(methodName){\n            return function(){\n              var args = toArray(arguments);\n              args.unshift(methodName);\n              enqueueInput(args);\n              processQueues();\n            };\n          })(action);\n        }\n      }\n    })();\n\n    //start so we don't have to wait for the first interval\n    readyCallback();\n    processQueues();\n  })(footprints.state.inputQueue,\n    footprints.state.outputQueue,\n    footprints.state.basePayload,\n    footprints.options.endpointUrl,\n    footprints.options.successCallback,\n    footprints.options.errorCallback,\n    footprints.options.uniqueIdFunc,\n    footprints.options.readyCallback,\n    footprints.options.debug\n  );\n}\n\nif(window[LIB_NAME]){\n  init(window[LIB_NAME]);\n}\n"],"sourceRoot":""}